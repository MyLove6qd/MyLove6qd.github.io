---
layout: post
title: 设计模式(一) 简单工厂模式
tags:
- Design_Patterns
categories:
- Design_Patterns
description: 我一直认为编程思想源于生活,很多一起学习的同学,总是有疑惑,我学的这些东西到底有什么用? 如果能举个例子,引入一定场景和故事.他们或许就很快明白了! 我很喜欢刘欣的<<码农翻身>>  用故事给技术加点料! 他是我学习的榜样 问题故事化!!!

---



# 设计模式(一) 简单工厂模式

## 1. 引子

我一直认为编程思想源于生活,很多一起学习的同学,总是有疑惑,我学的这些东西到底有什么用? 如果能举个例子,引入一定场景和故事.他们或许就很快明白了! 我很喜欢刘欣的<<码农翻身>>  用故事给技术加点料! 他是我学习的榜样 问题故事化!!!

## 2. 故事继续...

很不幸 我需要大费周章的和我的同事解释什么是工厂模式😂

很多类都有什么什么XXXFactory类 通常按照尿性还有一个createXXX()

比如我们的 阿里爸爸的Druid  DruidDataSourceFactory.createDataSource();  等等.

其实这就有工厂模式的体现,

工厂模式分为三种

1. 简单工厂模式
2. 工厂模式
3. 抽象工厂模式

---

## 3. 简单工厂模式

先来个官方的解释:

简单工厂模式:简单工厂模式其实不能算是一个设计模式,反而比较像一种编程习惯..............(省略300字)



我对工厂模式的理解源于我自己,编程只是我的副业 我其实是开火锅店的,哈哈哈

## 4. 我的火锅店

家族流传的手艺 祖传的火锅底料制作秘方 是我开火锅店的资本

开始我这边只是一个小店 我一直使用祖传的一套秘方经营着我的小店 很幸运 大家的反响很好 刚开业不到3个月,大家的口口相传 让我的火锅店生意火爆 很多周边城市的人们涌向这座小县城 只为那舌尖上的一丝快感......

日益增多的客流量 让我们每天的经营都是一次挑战 但是我作为这家店的主人 依旧自信满满  大学学习的erp课程 让我有一套优秀的管理方案 这套方案将会一直沿用	但是客人越来越多 口味也越来越多	我家的牛肉味火锅已经不能满足大众的口味了 最近肯德基推出怀旧系列 嫩牛五方  可口可乐推出了樱桃口味的可乐 网上火起来的华农兄弟让大家知道了竹鼠 前几天还有客人问我是否有竹鼠火锅........

必须添加新的菜品! 不作出改变就得迎来死亡!

于是我们按照顾客的要求添加了很多新的口味火锅,有牛肉火锅,羊肉火锅,菌菇火锅,.........当然还有竹鼠火锅
于是现在的火锅店成了这样:         方形为类

<div class="mermaid">
graph RL;
shop[MyStore<br/>1.优秀的管理方法];
	id[BeefHuoguo]-->shop;
	id2[LambHuoguo]-->shop;
	id3[BambooRatHuoguo]-->shop;
	id4[.....]-->shop;
</div>

当然我是一个熟悉OO思想的人----找出应用中可能需要变化之处,把他们独立出来,不要和那些不需要变化的代码混在一起

对于火锅的制作 有很多重复的操作 比如加汤 加油 加入 调料包 加热等等 我把这些公共的步骤写在墙上 大家都按这个操作步骤来就可以了

 所以我们可以把这些相同的部分抽象出来:

圆形为抽象类

<div class="mermaid">
graph RL;
	abstract((Huoguo<br/>1.加油方法<br/>2.加调料方法<br/>3.加热方法))-->shop[MyStore<br/>1.优秀的管理方法];
	id[BeefHuoguo]-.->abstract;
	id1[LambHuoguo]-.->abstract;
	id3[BambooRatHuoguo]-.->abstract;
	id4[.....]-.->abstract;
</div>

于是我们有了一层抽象类-----火锅 这些都是汤底的种类,子类有自己的实现 而重复的方法从父类继承

## 5. 工厂的加入

为了进一步加快速度 跟上信息化时代 同时减少开支 减少那些制作火锅的大妈们 我让我机械系的同学小王 连夜赶制了一台机器 用来制作火锅底料 这台机器只需要输入需要的火锅类型 他就可以生产出火锅!我把这个机器叫做HuoguoFactory

实现如下:

``` java
public class HuoguoFactory{
  public Huoguo createHuoguo(String name){	//拿到火锅的方法
    Huoguo huoguo = null;
    if(name.equals("BeffHuoguo")){
       huoguo = new BeffHuoguo();
    }else if(name.equals("LambHuoguo")){
       huoguo = new LambHuoguo();
    }else if(name.equals("BambooRatHuoguo")){
       huoguo = new BambooRatHuoguo();
    }
    ......
    return huoguo;
  }
}
```

现在的工作流程是这样了: 虚线为继承/实现关系

<div class="mermaid">
graph RL;
	HuoguoFactory[HuoguoFactory<br/>内部维护一个方法用来向使用者返回Huoguo]-->shop[MyStore<br/>内部有一个HuoguoFactory的引用<br/>1.优秀的管理方法];
	abstract((Huoguo<br/>1.加油方法<br/>2.加调料方法<br/>3.加热方法))-->HuoguoFactory
	id[BeefHuoguo]-.->abstract;
	id1[LambHuoguo]-.->abstract;
	id3[BambooRatHuoguo]-.->abstract;
	id4[.....]-.->abstract;
</div>

## 6. 简单工厂模式

好了 这就是我火锅店的现状

拥有了一台生产不同火锅的机器-----火锅工厂

这就是我理解的简单的工厂模式:

简单工厂有一个Factory工厂实体类,我们可以直接将参数交给工厂类,而不需要针对具体类new 对象 工厂类相当于对不同实现类对象创建了一个抽象层,对使用者来说是透明的(比如对于火锅店主的我 我根本不需要知道火锅工厂内部是怎么工作的 我只知道输入一个火锅名字 3分钟后就会有一盆香喷喷的火锅产出 端给客人就好了) 去除了对类实现的依赖,所以在一定程度上实现了解耦!

对于火锅店的管理者 也就是我 如果没有小王提供的火锅机器 没有这个缓冲层 我就需要在工厂的使用者MyStore中判断创建那种火锅 管理火锅店的事情和制作火锅的步骤都由我这个店长控制 太麻烦了 我只想专注我的管理 所以利用火锅工厂 将这个业务分离出去 这样我就可以一心的分配我的员工干活了 该接待的接待 该打扫的打扫 火锅制作就不需要操心了!!!